const express = require('express');
const { UserPhoneNumber, User, IncomingCall } = require('../models');
const auth = require('../middleware/auth');
const { client: twilioClient } = require('../config/twilio');
const { getPhoneNumberLocation } = require('../utils/phoneLocation');

const router = express.Router();

// è·å–ç”¨æˆ·çš„ç”µè¯å·ç åˆ—è¡¨
router.get('/', auth, async (req, res) => {
  try {
    // è·å–ç”¨æˆ·çš„é»˜è®¤æ¥ç”µæ˜¾ç¤ºè®¾ç½®
    const user = await User.findByPk(req.user.userId, {
      attributes: ['defaultCallerId']
    });

    const phoneNumbers = await UserPhoneNumber.findAll({
      where: { userId: req.user.userId },
      order: [['createdAt', 'DESC']],
      include: [
        {
          model: IncomingCall,
          as: 'incomingCalls',
          attributes: ['id', 'status', 'startTime'],
          limit: 5,
          order: [['startTime', 'DESC']],
          required: false
        }
      ]
    });

    // æ ¼å¼åŒ–å“åº”æ•°æ®
    const formattedNumbers = phoneNumbers.map(phone => ({
      id: phone.id,
      phoneNumber: phone.phoneNumber,
      type: phone.type,
      status: phone.status,
      callerIdName: phone.callerIdName,
      monthlyFee: parseFloat(phone.monthlyFee),
      setupFee: parseFloat(phone.setupFee),
      purchaseDate: phone.purchaseDate,
      expiryDate: phone.expiryDate,
      capabilities: phone.capabilities,
      // åœ°ç†ä½ç½®ä¿¡æ¯
      locality: phone.locality,
      region: phone.region,
      isoCountry: phone.isoCountry,
      // æ–°å¢ï¼šå¸ƒå°”å­—æ®µæ˜¾ç¤ºæ˜¯å¦ä¸ºé»˜è®¤æ¥ç”µæ˜¾ç¤º
      isDefaultCallerId: phone.isDefaultCallerId || false,
      settings: {
        forwardingEnabled: phone.forwardingEnabled,
        forwardingNumber: phone.forwardingNumber,
        voicemailEnabled: phone.voicemailEnabled,
        autoAnswer: phone.autoAnswer,
        businessHours: phone.businessHours,
        customGreeting: phone.customGreeting
      },
      statistics: {
        totalIncomingCalls: phone.totalIncomingCalls,
        totalIncomingMinutes: phone.totalIncomingMinutes,
        lastIncomingCall: phone.lastIncomingCall
      },
      recentCalls: phone.incomingCalls || []
    }));

    res.json({
      success: true,
      phoneNumbers: formattedNumbers,
      defaultCallerId: user?.defaultCallerId || null,
      total: formattedNumbers.length
    });

  } catch (error) {
    console.error('Error fetching phone numbers:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch phone numbers'
    });
  }
});

// è·å–å¯è´­ä¹°çš„å·ç åˆ—è¡¨ï¼ˆä»Twilioï¼‰
router.get('/available', auth, async (req, res) => {
  try {
    const { countryCode = 'US', areaCode, contains } = req.query;
    
    // åªå…è®¸ç¾å›½å’ŒåŠ æ‹¿å¤§
    if (!['US', 'CA'].includes(countryCode)) {
      return res.status(400).json({
        success: false,
        message: 'Phone numbers are only available for US and Canada'
      });
    }
    
    // æ¨¡æ‹Ÿæ•°æ® - åœ¨ç”Ÿäº§ç¯å¢ƒä¸­åº”è¯¥è°ƒç”¨Twilio API
    if (process.env.NODE_ENV === 'development' || !twilioClient) {
      // ç”Ÿæˆæ¨¡æ‹Ÿçš„å¯ç”¨å·ç 
      const mockNumbers = [];
      for (let i = 0; i < 10; i++) {
        const areaCodePrefix = areaCode || '555';
        const randomSuffix = Math.floor(Math.random() * 10000).toString().padStart(4, '0');
        const randomMiddle = Math.floor(Math.random() * 1000).toString().padStart(3, '0');
        const phoneNumber = `+1${areaCodePrefix}${randomMiddle}${randomSuffix}`;
        
        // ä½¿ç”¨åœ°ç†ä½ç½®å·¥å…·è·å–ä½ç½®ä¿¡æ¯
        const locationInfo = getPhoneNumberLocation(phoneNumber);
        
        mockNumbers.push({
          phoneNumber,
          friendlyName: `(${areaCodePrefix}) ${randomMiddle}-${randomSuffix}`,
          locality: locationInfo.locality,
          region: locationInfo.region,
          isoCountry: locationInfo.isoCountry,
          capabilities: {
            voice: true,
            sms: true,
            mms: false,
            fax: false
          },
          monthlyFee: 2.00,
          setupFee: 0.00
        });
      }
      
      return res.json({
        success: true,
        availableNumbers: mockNumbers,
        total: mockNumbers.length
      });
    }

    // å®é™…çš„Twilio APIè°ƒç”¨
    const searchParams = {
      countryCode,
      limit: 20
    };
    
    if (areaCode) {
      searchParams.areaCode = areaCode;
    }
    
    if (contains) {
      searchParams.contains = contains;
    }

    const availableNumbers = await twilioClient.availablePhoneNumbers(countryCode)
      .local
      .list(searchParams);

    const formattedNumbers = availableNumbers.map(number => ({
      phoneNumber: number.phoneNumber,
      friendlyName: number.friendlyName,
      locality: number.locality,
      region: number.region,
      isoCountry: number.isoCountry,
      capabilities: number.capabilities,
      monthlyFee: 2.00, // æ›´æ–°è´¹ç‡
      setupFee: 0.00
    }));

    res.json({
      success: true,
      availableNumbers: formattedNumbers,
      total: formattedNumbers.length
    });

  } catch (error) {
    console.error('Error fetching available numbers:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch available numbers'
    });
  }
});

// è´­ä¹°ç”µè¯å·ç 
router.post('/purchase', auth, async (req, res) => {
  try {
    const { phoneNumber, callerIdName } = req.body;
    
    if (!phoneNumber) {
      return res.status(400).json({
        success: false,
        message: 'Phone number is required'
      });
    }

    // æ£€æŸ¥ç”¨æˆ·ä½™é¢
    const user = await User.findByPk(req.user.userId);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    const setupFee = 0.00;
    const monthlyFee = 2.00;
    
    if (user.balance < setupFee + monthlyFee) {
      return res.status(400).json({
        success: false,
        message: 'Insufficient balance. Please add credits.'
      });
    }

    // æ£€æŸ¥å·ç æ˜¯å¦å·²è¢«è´­ä¹°
    const existingNumber = await UserPhoneNumber.findOne({
      where: { phoneNumber }
    });

    if (existingNumber) {
      return res.status(409).json({
        success: false,
        message: 'This phone number is already taken'
      });
    }

    let twilioSid = null;
    
    // æ¨¡æ‹Ÿè´­ä¹° - åœ¨å¼€å‘ç¯å¢ƒä¸­æˆ–Twilioæœªé…ç½®æ—¶
    if (process.env.NODE_ENV === 'development' || !twilioClient) {
      console.log('Development mode: Simulating phone number purchase');
      twilioSid = `PN${Date.now()}${Math.random().toString(36).substr(2, 9)}`;
    } else {
      try {
        // å®é™…ä»Twilioè´­ä¹°å·ç 
        const purchasedNumber = await twilioClient.incomingPhoneNumbers.create({
          phoneNumber: phoneNumber,
          voiceUrl: `${process.env.APP_URL || process.env.BASE_URL || 'https://ubophone.com'}/api/incoming-calls/webhook/voice`,
          voiceMethod: 'POST',
          statusCallback: `${process.env.APP_URL || process.env.BASE_URL || 'https://ubophone.com'}/api/incoming-calls/webhook/dial-status`,
          statusCallbackMethod: 'POST'
        });
        
        twilioSid = purchasedNumber.sid;
      } catch (twilioError) {
        console.error('Twilio purchase error:', twilioError);
        return res.status(400).json({
          success: false,
          message: `Failed to purchase number: ${twilioError.message}`
        });
      }
    }

    // è·å–ç”µè¯å·ç çš„åœ°ç†ä½ç½®ä¿¡æ¯
    const locationInfo = getPhoneNumberLocation(phoneNumber);
    
    // åœ¨æ•°æ®åº“ä¸­åˆ›å»ºè®°å½•
    const userPhoneNumber = await UserPhoneNumber.create({
      userId: req.user.userId,
      phoneNumber,
      type: 'dedicated',
      status: 'active',
      twilioSid,
      locality: locationInfo.locality,
      region: locationInfo.region,
      isoCountry: locationInfo.isoCountry,
      callerIdName: callerIdName || `${user.firstName || user.username}'s Phone`,
      monthlyFee,
      setupFee,
      purchaseDate: new Date()
    });

    // æ‰£é™¤è´¹ç”¨
    const totalCost = setupFee + monthlyFee;
    await user.update({
      balance: parseFloat(user.balance) - totalCost
    });

    // æ ¼å¼åŒ–å“åº”
    const responseData = {
      id: userPhoneNumber.id,
      phoneNumber: userPhoneNumber.phoneNumber,
      callerIdName: userPhoneNumber.callerIdName,
      type: userPhoneNumber.type,
      status: userPhoneNumber.status,
      monthlyFee: parseFloat(userPhoneNumber.monthlyFee),
      setupFee: parseFloat(userPhoneNumber.setupFee),
      purchaseDate: userPhoneNumber.purchaseDate,
      remainingBalance: parseFloat(user.balance)
    };

    res.json({
      success: true,
      phoneNumber: responseData,
      message: `Phone number ${phoneNumber} purchased successfully`,
      totalCost
    });

  } catch (error) {
    console.error('Error purchasing phone number:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to purchase phone number'
    });
  }
});

// æ›´æ–°ç”µè¯å·ç è®¾ç½®
router.put('/:id/settings', auth, async (req, res) => {
  try {
    const { id } = req.params;
    const {
      callerIdName,
      forwardingEnabled,
      forwardingNumber,
      voicemailEnabled,
      autoAnswer,
      businessHours,
      customGreeting
    } = req.body;

    const phoneNumber = await UserPhoneNumber.findOne({
      where: {
        id,
        userId: req.user.userId
      }
    });

    if (!phoneNumber) {
      return res.status(404).json({
        success: false,
        message: 'Phone number not found'
      });
    }

    // æ›´æ–°è®¾ç½®
    const updateData = {};
    if (callerIdName !== undefined) updateData.callerIdName = callerIdName;
    if (forwardingEnabled !== undefined) updateData.forwardingEnabled = forwardingEnabled;
    if (forwardingNumber !== undefined) updateData.forwardingNumber = forwardingNumber;
    if (voicemailEnabled !== undefined) updateData.voicemailEnabled = voicemailEnabled;
    if (autoAnswer !== undefined) updateData.autoAnswer = autoAnswer;
    if (businessHours !== undefined) updateData.businessHours = businessHours;
    if (customGreeting !== undefined) updateData.customGreeting = customGreeting;

    await phoneNumber.update(updateData);

    res.json({
      success: true,
      phoneNumber: {
        id: phoneNumber.id,
        phoneNumber: phoneNumber.phoneNumber,
        callerIdName: phoneNumber.callerIdName,
        settings: {
          forwardingEnabled: phoneNumber.forwardingEnabled,
          forwardingNumber: phoneNumber.forwardingNumber,
          voicemailEnabled: phoneNumber.voicemailEnabled,
          autoAnswer: phoneNumber.autoAnswer,
          businessHours: phoneNumber.businessHours,
          customGreeting: phoneNumber.customGreeting
        }
      },
      message: 'Settings updated successfully'
    });

  } catch (error) {
    console.error('Error updating phone number settings:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update settings'
    });
  }
});

// ğŸ”§ æ›´æ–°æ¥ç”µå¤„ç†è®¾ç½®
router.put('/:id/incoming-settings', auth, async (req, res) => {
  try {
    const { id } = req.params;
    const {
      incomingCallMode,
      forwardingEnabled,
      forwardingNumber
    } = req.body;

    const phoneNumber = await UserPhoneNumber.findOne({
      where: {
        id,
        userId: req.user.userId
      }
    });

    if (!phoneNumber) {
      return res.status(404).json({
        success: false,
        message: 'Phone number not found'
      });
    }

    // éªŒè¯è¾“å…¥æ•°æ®
    if (incomingCallMode && !['forward', 'browser'].includes(incomingCallMode)) {
      return res.status(400).json({
        success: false,
        message: 'Invalid incoming call mode. Must be "forward" or "browser"'
      });
    }

    if (incomingCallMode === 'forward' && forwardingEnabled && !forwardingNumber) {
      return res.status(400).json({
        success: false,
        message: 'Forwarding number is required when forwarding is enabled'
      });
    }

    // æ„å»ºæ›´æ–°æ•°æ®
    const updateData = {};
    if (forwardingEnabled !== undefined) updateData.forwardingEnabled = forwardingEnabled;
    if (forwardingNumber !== undefined) updateData.forwardingNumber = forwardingNumber;

    // æ ¹æ®æ¨¡å¼è®¾ç½®ç›¸åº”çš„å­—æ®µ
    if (incomingCallMode === 'forward') {
      updateData.forwardingEnabled = true;
      updateData.forwardingNumber = forwardingNumber;
    } else if (incomingCallMode === 'browser') {
      updateData.forwardingEnabled = false;
      updateData.forwardingNumber = null;
    }

    await phoneNumber.update(updateData);

    console.log(`ğŸ“ Updated incoming call settings for ${phoneNumber.phoneNumber}:`, {
      mode: incomingCallMode,
      forwardingEnabled: updateData.forwardingEnabled,
      forwardingNumber: updateData.forwardingNumber
    });

    res.json({
      success: true,
      phoneNumber: {
        id: phoneNumber.id,
        phoneNumber: phoneNumber.phoneNumber,
        settings: {
          forwardingEnabled: phoneNumber.forwardingEnabled,
          forwardingNumber: phoneNumber.forwardingNumber,
          voicemailEnabled: phoneNumber.voicemailEnabled,
          autoAnswer: phoneNumber.autoAnswer,
          businessHours: phoneNumber.businessHours,
          customGreeting: phoneNumber.customGreeting
        }
      },
      message: 'Incoming call settings updated successfully'
    });

  } catch (error) {
    console.error('Error updating incoming call settings:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to update incoming call settings'
    });
  }
});

// åˆ é™¤/é‡Šæ”¾ç”µè¯å·ç 
router.delete('/:id', auth, async (req, res) => {
  try {
    const { id } = req.params;

    const phoneNumber = await UserPhoneNumber.findOne({
      where: {
        id,
        userId: req.user.userId
      }
    });

    if (!phoneNumber) {
      return res.status(404).json({
        success: false,
        message: 'Phone number not found'
      });
    }

    // åœ¨ç”Ÿäº§ç¯å¢ƒä¸­é‡Šæ”¾Twilioå·ç 
    if (phoneNumber.twilioSid && twilioClient && process.env.NODE_ENV !== 'development') {
      try {
        await twilioClient.incomingPhoneNumbers(phoneNumber.twilioSid).remove();
      } catch (twilioError) {
        console.error('Failed to release Twilio number:', twilioError);
        // å³ä½¿Twilioé‡Šæ”¾å¤±è´¥ï¼Œä¹Ÿç»§ç»­åˆ é™¤æ•°æ®åº“è®°å½•
      }
    }

    // å°†çŠ¶æ€è®¾ä¸º inactive è€Œä¸æ˜¯ç›´æ¥åˆ é™¤ï¼ˆä¿ç•™å†å²è®°å½•ï¼‰
    await phoneNumber.update({
      status: 'inactive',
      expiryDate: new Date()
    });

    res.json({
      success: true,
      message: `Phone number ${phoneNumber.phoneNumber} has been released`
    });

  } catch (error) {
    console.error('Error releasing phone number:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to release phone number'
    });
  }
});

// è·å–å·ç çš„æ¥ç”µå†å²
router.get('/:id/incoming-calls', auth, async (req, res) => {
  try {
    const { id } = req.params;
    const { page = 1, limit = 20, status } = req.query;
    const offset = (page - 1) * limit;

    const phoneNumber = await UserPhoneNumber.findOne({
      where: {
        id,
        userId: req.user.userId
      }
    });

    if (!phoneNumber) {
      return res.status(404).json({
        success: false,
        message: 'Phone number not found'
      });
    }

    const whereClause = {
      userPhoneNumberId: id
    };

    if (status) {
      whereClause.status = status;
    }

    const calls = await IncomingCall.findAndCountAll({
      where: whereClause,
      order: [['startTime', 'DESC']],
      limit: parseInt(limit),
      offset: parseInt(offset),
      attributes: [
        'id', 'callSid', 'fromNumber', 'status', 'startTime', 
        'answerTime', 'endTime', 'duration', 'handledBy',
        'hasRecording', 'hasVoicemail', 'isSpam', 'userNotes'
      ]
    });

    res.json({
      success: true,
      phoneNumber: phoneNumber.phoneNumber,
      calls: calls.rows,
      pagination: {
        total: calls.count,
        totalPages: Math.ceil(calls.count / limit),
        currentPage: parseInt(page),
        limit: parseInt(limit)
      }
    });

  } catch (error) {
    console.error('Error fetching incoming calls:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to fetch incoming calls'
    });
  }
});

// è®¾ç½®é»˜è®¤æ¥ç”µæ˜¾ç¤ºå·ç 
router.post('/default-caller-id', auth, async (req, res) => {
  try {
    const { phoneNumberId } = req.body;

    // è·å–ç”¨æˆ·
    const user = await User.findByPk(req.user.userId);
    if (!user) {
      return res.status(404).json({
        success: false,
        message: 'User not found'
      });
    }

    // å¦‚æœè®¾ç½®ä¸ºnullï¼Œè¡¨ç¤ºæ¸…é™¤é»˜è®¤æ¥ç”µæ˜¾ç¤º
    if (phoneNumberId === null) {
      // æ¸…é™¤ç”¨æˆ·çš„é»˜è®¤æ¥ç”µæ˜¾ç¤ºè®¾ç½®
      await user.update({ defaultCallerId: null });
      
      // å°†è¯¥ç”¨æˆ·çš„æ‰€æœ‰å·ç çš„isDefaultCallerIdè®¾ä¸ºfalse
      await UserPhoneNumber.update(
        { isDefaultCallerId: false },
        { where: { userId: req.user.userId } }
      );
      
      return res.json({
        success: true,
        defaultCallerId: null,
        message: 'Default caller ID removed'
      });
    }

    // éªŒè¯ç”µè¯å·ç æ˜¯å¦å±äºè¯¥ç”¨æˆ·
    const phoneNumber = await UserPhoneNumber.findOne({
      where: {
        id: phoneNumberId,
        userId: req.user.userId,
        status: 'active' // åªæœ‰æ´»è·ƒçš„å·ç æ‰èƒ½è®¾ä¸ºé»˜è®¤
      }
    });

    if (!phoneNumber) {
      return res.status(404).json({
        success: false,
        message: 'Phone number not found or not active'
      });
    }

    // ğŸ”„ åŒæ­¥æ›´æ–°ä¸¤ç§æ–¹æ¡ˆï¼š
    // æ–¹æ¡ˆ1ï¼šæ›´æ–°usersè¡¨çš„defaultCallerIdå­—æ®µ
    await user.update({ defaultCallerId: phoneNumberId });
    
    // æ–¹æ¡ˆ2ï¼šæ›´æ–°user_phone_numbersè¡¨çš„å¸ƒå°”å­—æ®µ
    // å…ˆå°†è¯¥ç”¨æˆ·çš„æ‰€æœ‰å·ç è®¾ä¸ºéé»˜è®¤
    await UserPhoneNumber.update(
      { isDefaultCallerId: false },
      { where: { userId: req.user.userId } }
    );
    
    // ç„¶åå°†é€‰ä¸­çš„å·ç è®¾ä¸ºé»˜è®¤
    await UserPhoneNumber.update(
      { isDefaultCallerId: true },
      { where: { id: phoneNumberId, userId: req.user.userId } }
    );

    res.json({
      success: true,
      defaultCallerId: phoneNumberId,
      phoneNumber: phoneNumber.phoneNumber,
      message: `Default caller ID set to ${phoneNumber.phoneNumber}`
    });

  } catch (error) {
    console.error('Error setting default caller ID:', error);
    res.status(500).json({
      success: false,
      message: 'Failed to set default caller ID'
    });
  }
});

module.exports = router;